<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
	fill: lightyellow;
	stroke: white;
	//stroke-opacity: .5;
	stroke-linecap: round;
}

path:hover {
	stroke-width: 10px !important;
	stroke: yellow;
	stroke-opacity: 1;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.tooltip {
	background-color: white;
	border: 1px solid gray;
	padding: 5px 10px;
}

</style>
<body>
<h1>Triangle treemap</h1>

<svg></svg>

<script src="./d3.v3.min.js"></script>
<script src="./dsutils.js"></script>
<script src="./triangle-treemap.js"></script>
<script>

var margin = {top: 20, right: 20, bottom: 20, left: 20},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
        .attr("transform","translate("+margin.top+","+margin.left+")");

var partition = d3.layout.partition()
    .sort(null)
    .size([500,500]) //dummy
    .value(function(d) { return 1; });

var color = d3.scale.category10();

function setColors(node,idx) {
  if(typeof node.parent === 'undefined') {
    if(node.children != null) {
      node.children.forEach(function(n,i){setColors(n,idx)});
    }
  } else {
    var pc = node.parent.color;
    if(typeof pc === 'undefined') { 
      node.color = color(node.name); //first level after root -> fixed color
    } else {
      var c = d3.hsl(pc);//.brighter(0.4);
      var m = idx / node.parent.children.length;
      node.color = d3.hsl(c.h, c.s * Math.pow(0.97, m) , c.l * 1.1).toString();
      //node.color = c.toString();
    }
    if(node.children != null) {
      node.children.forEach(function(n,i){setColors(n,idx)});
    }
  }
}

// un triangle d'essai
//isocèle
var t = [
  {x: 0.8 * 0.5 * width, y: 0},
  {x: 0, y: 0.8 * height},
  {x: 0.8 * width, y: 0.8 * height}
];


//rectangle
/*
var t = [
  {x: 0, y: 0.8*height},
  {x: 0, y: 0},
  {x: 0.8*width, y: 0.8*height}
];
*/

// Visual - draw triangle as path

// helper function in triangle
var coord = function(tt) {
  return (tt.x + " " + tt.y);
}

// returns d attribute of path for a triangle
var triangle = function(t) {
  return "M" + coord(t[0]) +
         " L"+ coord(t[1]) +
         " L"+ coord(t[2]) +
         "Z";
}



////////////////////////////////////////////////

var rt;
d3.json("flare.json", function(error, root) {
  if (error) throw error;

  nodes = partition.nodes(root);
  //console.log(root);
  rt = nodes[0];
  setColors(nodes[0],0);

  var start = new Date().getTime();
  treemap(nodes[0], t, 0, true); // squarify
  //treemap(nodes[0], t, 0, false); // don't squarify

/////////////////////
  svg.selectAll("path")
  	.data(nodes).enter()
  	.append("path")
    	.attr("d", function(d) { return triangle(d.triangle); })
    	//.style("stroke-width", function(d) { return stroke(d.depth); })
    	.style("fill", function(d) { return d.color; })
    	.attr("name", function(d) {
    		return ( 
    			d.name + 
    			" lvl " + d.depth + 
    			" surface " + surface(d.triangle) + 
    			" value "+d.value
    		);
    	});
/////////////////////
  var end = new Date().getTime();
  var time = end - start;
  console.log('Execution time: ' + time + 'ms');

  //tooltip
  var tt = ds.ttip();
  svg.selectAll("path")
    .on("mouseover", function(d,i) { tt.html(d3.select(this).node().getAttribute("name")).show(d,i,this); })
    .on("mouseout", tt.hide);
});


// TEST WITH FAKE DATA
/*

// des données réelles d'essai
var buildK = function(k,v,c) {
  return {name: k, value: v, children: c}
}

var fifi = [ buildK("fifi", 0.55, null), buildK("fifi", 0.15, null), buildK("fifi", 0.15, null), buildK("fifi", 0.15, null) ];
var fi = [ buildK("fi", 0.5, fifi), buildK("fi", 0.5, fifi) ];
var filler = [ buildK("filler", 10, null), buildK("filler", 10, null)];

//  d0 = 1
//     d1 = 0.5
//       d11 = 0.2
//       d12 = 0.3
//     d2 = 0.5
//       d21 = 0.1
//       d22 = 0.4

// structure
//   key:
//   value:
//   children

var data = 
      buildK("d0", 100, 
        [ buildK("d1", 60, 
            [ buildK("d11", 20, filler), buildK("d12", 20, filler), buildK("d12", 20, filler) ] 
            //null
          ),
          buildK("d2", 40, 
            [ buildK("d21", 20, filler), buildK("d22", 20, filler) ]
            //null
          )
        ]
      );

var nn = partition.nodes(data);
setColors(nn[0],0);
treemap(nn[0], t, 0);
svg.selectAll("path")
  	.data(nn).enter()
  	.append("path")
    	.attr("d", function(d) { return triangle(d.triangle); })
    	//.style("stroke-width", stroke(lvl))
    	.style("fill", function(d) { return d.color; })
    	.attr("name", function(d) {
    		return ( 
    			d.name + 
    			" lvl " + d.depth + 
    			" surface " + surface(d.triangle) + 
    			" value "+d.value
    		);
    	});
*/
// zoom
//Overlay for catching zoom events
/*
svg.append("rect")
    .attr("class", "overlay")
    .attr("width", width)
    .attr("height", height)
    .call(zoom);

//set width according to zoom
function zoomed() {
  //svg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  //svg.select("path").style("stroke-width", .5 / d3.event.scale + "px");
}
*/

</script>
</body>
</html>