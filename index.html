<!DOCTYPE html>
<meta charset="utf-8">
<style>

path {
	fill: lightyellow;
	stroke: white;
	//stroke-opacity: .5;
	stroke-linecap: round;
}

path:hover {
	stroke-width: 10px !important;
	stroke: yellow;
	stroke-opacity: 1;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.tooltip {
	background-color: white;
	border: 1px solid gray;
	padding: 5px 10px;
}

</style>
<body>
<h1>Triangle treemap</h1>
<!--
<form>
  <label><input type="radio" name="mode" value="size" checked> Size</label>
  <label><input type="radio" name="mode" value="count"> Count</label>
</form>
-->
<svg></svg>

<script src="./d3.v3.min.js"></script>
<script src="./dsutils.js"></script>
<script src="./triangle-treemap.js"></script>
<script>

var margin = {top: 20, right: 20, bottom: 20, left: 20},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;

var svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
        .attr("transform","translate("+margin.top+","+margin.left+")");

var partition = d3.layout.partition()
    .sort(null)
    .size([500,500]) //dummy
    .value(function(d) { return 1; });

var color = d3.scale.category10();

function setColors(node,idx) {
  if(node.depth === 0) {
  	node.color = null;
    if(node.children != null) {
      node.children.forEach(function(n,i){setColors(n,idx)});
    }
  } else {
    var pc = node.parent.color;
    if(node.depth === 1) { 
      node.color = color(node.name); //first level after root -> fixed color
    } else {
      var c = d3.hsl(pc);//.brighter(0.4);
      var m = idx / node.parent.children.length;
      node.color = d3.hsl(c.h, c.s * Math.pow(0.97, m) , c.l * 1.1).toString();
      //node.color = c.toString();
    }
    if(node.children != null) {
      node.children.forEach(function(n,i){setColors(n,idx)});
    }
  }
}

// Container triangle
// isocele

var t = [
  {x: 0.8 * 0.5 * width, y: 0},
  {x: 0, y: 0.8 * height},
  {x: 0.8 * width, y: 0.8 * height}
];

// equilateral
/*
var a = height * 0.8,
    h = 0.5 * Math.sqrt(3) * a;
var t = [
  {x: 0.5 * width, y: 0},
  {x: 0.5 * ( width + a ), y: h},
  {x: 0.5 * ( width - a ), y: h}
];
*/

/*
//rectangle
var t = [
  {x: 0, y: 0.8*height},
  {x: 0, y: 0},
  {x: 0.8*width, y: 0.8*height}
];
*/


// Visual - draw triangle as path

// helper function in triangle
var coord = function(tt) {
  return (tt.x + " " + tt.y);
}

// returns d attribute of path for a triangle
var triangle = function(t) {
  return "M" + coord(t[0]) +
         " L"+ coord(t[1]) +
         " L"+ coord(t[2]) +
         "Z";
}

/// Load data and display 
var rt;
d3.json("flare.json", function(error, root) {
  if (error) throw error;


  //nodes = partition.value(function(d) { return d.size; }).nodes(root);
  //nodes = partition.nodes(root);
  //rt = nodes[0];
  //setColors(nodes[0],0);

  var start = new Date().getTime();

/////////////////////  
  //treemap(nodes[0], t, true); // squarify
  //treemap(nodes[0], t, false); // don't squarify
/////////////////////
  
  //nodes.forEach(function(n,i){ setColors(n,i) });



 // var selection = svg.selectAll("path")
 // 	.data(nodes).enter()
   var selection = svg.datum(root).selectAll(".node")
      .data(function(root) {
      	var r = partition.nodes(root); 
      	setColors(r[0],0); 
      	treemap(r[0], t, true); 
      	return r; 
      })
      .enter()
  	.append("path")
    	.attr("d", function(d) { return triangle(d.triangle); })
    	//.style("stroke-width", function(d) { return stroke(d.depth); })
    	.style("fill", function(d) { return d.color; })
    	//.style("fill", function(d, i) { return (Math.random() > 0.5 ? "black" : "#ddd"); })
    	//.style("fill", function(d, i) { return (i % 2 === 0 ? "black" : "white"); })
    	.attr("name", function(d) {
    		return ( 
    			d.name + 
    			" lvl " + d.depth + 
    			" surface " + surface(d.triangle) + 
    			" value "+d.value
    		);
    	});

/////////////////////
  var end = new Date().getTime();
  var time = end - start;
  console.log('Execution time: ' + time + 'ms');

  // tooltip
  var tt = ds.ttip();
  svg.selectAll("path")
    .on("mouseover", function(d,i) { tt.html(d3.select(this).node().getAttribute("name")).show(d,i,this); })
    .on("mouseout", tt.hide);



//////////////
// FIXME : dont work : why ? conflict between treemap and partition ?
/*
  d3.selectAll("input").on("change", function change() {
    var value = this.value === "count"
        ? function() { return 1; }
        : function(d) { return d.size; };

    selection
      .data(function(root) {
      	var r = partition.value(value).nodes(root); 
      	treemap(r[0], t, true); 
      	return r; 
      })
      .transition()
        .duration(1500)
        .attr("d", function(d) { return triangle(d.triangle); });
  });
*/



});


// TEST WITH FAKE DATA
/*
// des données réelles d'essai
var buildK = function(k,v,c) {
  return {name: k, value: v, children: c}
}

var fifi = [ buildK("fifi", 0.55, null), buildK("fifi", 0.15, null), buildK("fifi", 0.15, null), buildK("fifi", 0.15, null) ];
var fi = [ buildK("fi", 0.5, fifi), buildK("fi", 0.5, fifi) ];
var filler = [ buildK("filler", 10, null), buildK("filler", 10, null)];

//  d0 = 1
//     d1 = 0.5
//       d11 = 0.2
//       d12 = 0.3
//     d2 = 0.5
//       d21 = 0.1
//       d22 = 0.4

// structure
//   key:
//   value:
//   children

var data = 
      buildK("d0", 100, 
        [ buildK("d1", 60, 
            [ buildK("d11", 20, filler), buildK("d12", 20, filler), buildK("d12", 20, filler) ] 
            //null
          ),
          buildK("d2", 40, 
            [ buildK("d21", 20, filler), buildK("d22", 20, filler) ]
            //null
          )
        ]
      );

function fill(d, nochildren, depth) {
	if(depth == 0) {
		return buildK("d"+depth,1,null);
	} else {
		var val = 0;
		d.children = new Array(nochildren);
		for(var i=0; i<nochildren; i++) {
			var n = buildK("d"+depth,1,null);
			fill(n, nochildren, depth-1);
			//console.log(n);
			//console.log(d);
			d.children[i] = n;
			val += n.value;
		}
		d.value = val;
	}
}

var data2 = buildK("d0",1,null);
//fill(data2, 4, 5);
fill(data2, 2, 4);


var nn = partition.nodes(data2);
setColors(nn[0],0);
treemap(nn[0], t, true);
svg.selectAll("path")
  	.data(nn).enter()
  	.append("path")
    	.attr("d", function(d) { return triangle(d.triangle); })
    	//.style("stroke-width", stroke(lvl))
    	.style("fill", function(d) { return d.color; })
    	.attr("name", function(d) {
    		return ( 
    			d.name + 
    			" lvl " + d.depth + 
    			" surface " + surface(d.triangle) + 
    			" value "+d.value
    		);
    	});
//debug
d3.selectAll("path").each(
	function(d){
		console.log(
			"value: "+d.value
			+" surface: "+surface(d.triangle))
	});
*/

</script>
</body>
</html>